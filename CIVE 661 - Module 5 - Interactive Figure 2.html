<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>SDOF Step (Damped)</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      background: #fff;
      color: #000;
    }

    /* Keep constants and sliders in single rows */
    #constants, #controls {
      display: flex;
      justify-content: center;
      align-items: center;
      flex-wrap: nowrap;      /* keep all beside each other */
      gap: 40px;              /* spacing between inputs */
      margin: 10px 0;
    }

    .constant, .control {
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    input[type="number"], input[type="range"] {
      width: 160px;
    }

    input[type="number"] {
      text-align: center;
      border: 1px solid #ccc;
      border-radius: 4px;
      padding: 4px;
    }

    canvas {
      max-width: 800px;
      width: 100%;
      height: 400px;
      margin: 10px auto;
      display: block;
      background: #fff;
    }
  </style>
</head>
<body>
  <!-- Constants -->
  <div id="constants">
    <div class="constant">
      <label for="p0" style="font-size: 14px;">Step force <i> pâ‚€ </i> (N)</label>
      <input type="number" id="p0" value="1" step="0.1" min="0" max="1.2">
    </div>
    <div class="constant">
      <label for="k" style="font-size: 14px;">Stiffness <i> k </i> (N/m)</label>
      <input type="number" id="k" value="1" step="0.1" min="0.5">
    </div>
    <div class="constant">
      <label for="m" style="font-size: 14px;">Mass <i> m </i> (kg)</label>
      <input type="number" id="m" value="1" step="0.1" min="0.1">
    </div>
  </div>

  <!-- Sliders: u0, uÌ‡0, Î¶ -->
  <div id="controls">
    <div class="control" style="text-align:center; margin:auto;">
      <label for="u0" style="font-size: 14px;">Initial displacement<br> <i> uâ‚€ </i>(m)= <span id="u0_val">0.00</span></label>
      <input type="range" id="u0" min="-1" max="1" step="0.01" value="0">
    </div>


    <div class="control" style="text-align:center; margin:auto;">
      <label for="ud0" style="font-size: 14px;">Initial velocity<br> <i> uÌ‡ â‚€</i> (m/s)= <span id="ud0_val">0.00</span></label>
      <input type="range" id="ud0" min="-2" max="2" step="0.01" value="0">
    </div>
    <div class="control" style="text-align:center; margin:auto;">
      <label for="zeta" style="font-size:14px;">
        Damping ratio<br> <i> Î¶ </i>= <span id="zeta_val">0.00</span>
      </label>
      <input type="range" id="zeta" min="0" max="0.30" step="0.005" value="0">
    </div>

  </div>


  <canvas id="plot"></canvas>

  <script>
    // Sharper lines & larger fonts
    Chart.defaults.devicePixelRatio = 2;
    Chart.defaults.font.size = 14;

    const canvas = document.getElementById("plot");
    const ctx = canvas.getContext("2d");

    // Parameters
    let m = 1, k = 1, p0 = 1, zeta = 0.0;
    const T = 20, dt = 0.01;

    // Compute u(t) for a damped SDOF under step load with ICs (underdamped 0 <= Î¶ < 1)
    function computeSeries(u0, ud0) {
      const wn = Math.sqrt(k / m);
      const beta = Math.sqrt(Math.max(0, 1 - zeta * zeta)); // guard tiny negatives
      const wd = wn * beta;

      const pts = [];
      for (let i = 0; i <= T / dt; i++) {
        const t = i * dt;

        // Step response (particular) for 0<=Î¶<1:
        // u_step = (p0/k) [ 1 - e^{-Î¶ Ï‰n t} ( cos(Ï‰d t) + (Î¶/Î²) sin(Ï‰d t) ) ]
        const expTerm = Math.exp(-zeta * wn * t);
        const u_step = (p0 / k) * (1 - expTerm * (Math.cos(wd * t) + (zeta / (beta || 1)) * Math.sin(wd * t)));

        // Free response from ICs:
        // u_free = e^{-Î¶ Ï‰n t} [ u0 cos(Ï‰d t) + ((ud0 + Î¶ Ï‰n u0)/Ï‰d) sin(Ï‰d t) ]
        let u_free = 0;
        if (wd > 0) {
          u_free = expTerm * (u0 * Math.cos(wd * t) + ((ud0 + zeta * wn * u0) / wd) * Math.sin(wd * t));
        } else {
          // Limit as Î¶ â†’ 1 (very high damping): treat as no oscillation
          u_free = expTerm * (u0 + (ud0 + zeta * wn * u0) * t);
        }

        pts.push({ x: t, y: u_step + u_free });
      }
      return pts;
    }

    // Static displacement line y = p0/k
    function staticLine() {
      const y = p0 / k;
      return [{ x: 0, y }, { x: T, y }];
    }

    // Custom plugin: draw black axes through (0,0)
    const axesLines = {
      id: 'axesLines',
      afterDraw(chart) {
        const { ctx, chartArea: { left, right, top, bottom }, scales: { x, y } } = chart;
        ctx.save();
        ctx.strokeStyle = 'black';
        ctx.lineWidth = 1.5;
        // x-axis (u = 0)
        const yZero = y.getPixelForValue(0);
        if (yZero >= top && yZero <= bottom) {
          ctx.beginPath(); ctx.moveTo(left, yZero); ctx.lineTo(right, yZero); ctx.stroke();
        }
        // y-axis (t = 0)
        const xZero = x.getPixelForValue(0);
        if (xZero >= left && xZero <= right) {
          ctx.beginPath(); ctx.moveTo(xZero, top); ctx.lineTo(xZero, bottom); ctx.stroke();
        }
        ctx.restore();
      }
    };

    // Chart
    const chart = new Chart(ctx, {
      type: "line",
      data: {
        datasets: [
          { label: "ð‘¢(t)",
            data: computeSeries(0, 0),
            borderColor: "red",
            borderWidth: 1.5,
            pointRadius: 0,
            fill: false,
            parsing: false
          },
          { label: "ð‘â‚€/ð‘˜ (static)",
            data: staticLine(),
            borderColor: "#000",
            borderWidth: 1,
            borderDash: [6, 6],
            pointRadius: 0,
            fill: false,
            parsing: false
          }
        ]
      },
      options: {
        responsive: true,
        animation: false,
        scales: {
          x: {
            type: "linear",
            min: 0, max: 20,
            ticks: {
              color: "black",
              stepSize: 1,
              callback: v => Number.isInteger(v) ? v : ""
            },
            grid: { color: "#eee", drawBorder: false },
            title: { display: true, text: "Time ð‘¡ (s)", color: "black", font: { size: 16 } }
          },
          y: {
            min: -2, max: 4,                   
            ticks: { color: "black" },
            grid: { color: "#eee", drawBorder: false },
            title: { display: true, text: "Displacement ð‘¢(t) (m)", color: "black", font: { size: 16 } }
          }
        },
        plugins: {
          legend: {
            display: true,
            position: 'top',
            labels: { color: 'black', usePointStyle: false, boxWidth: 50, boxHeight: 0 }
          }
        },
        layout: { padding: 10 }
      },
      plugins: []
    });

    // Update on any input
    function updatePlot() {
      const u0  = parseFloat(document.getElementById("u0").value);
      const ud0 = parseFloat(document.getElementById("ud0").value);
      zeta = parseFloat(document.getElementById("zeta").value);
      document.getElementById("u0_val").textContent   = u0.toFixed(2);
      document.getElementById("ud0_val").textContent  = ud0.toFixed(2);
      document.getElementById("zeta_val").textContent = zeta.toFixed(3);

      m  = parseFloat(document.getElementById("m").value);
      k  = parseFloat(document.getElementById("k").value);
      p0 = parseFloat(document.getElementById("p0").value);

      chart.data.datasets[0].data = computeSeries(u0, ud0);
      chart.data.datasets[1].data = staticLine();
      chart.update();
    }

    document.querySelectorAll("input").forEach(el => el.addEventListener("input", updatePlot));
  </script>
</body>
</html>
