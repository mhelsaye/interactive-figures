<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>SDOF Free Vibration (Undamped)</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      background: #fff;
      color: #000;
    }

    /* Keep constants and sliders in single rows */
    #constants, #controls {
      display: flex;
      justify-content: center;
      align-items: center;
      flex-wrap: nowrap;
      gap: 40px;
      margin: 10px 0;
    }

    .constant, .control {
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    input[type="number"], input[type="range"] {
      width: 160px;
    }

    input[type="number"] {
      text-align: center;
      border: 1px solid #ccc;
      border-radius: 4px;
      padding: 4px;
    }

    canvas {
      max-width: 800px;
      width: 100%;
      height: 400px;
      margin: 10px auto;
      display: block;
      background: #fff;
    }
  </style>
</head>
<body>
  <!-- Constants -->
  <div id="constants">
    <div class="constant">
      <label for="k" style="font-size: 14px;">Stiffness <i> k </i> (N/m)</label>
      <input type="number" id="k" value="1" step="0.1" min="0.5">
    </div>
    <div class="constant">
      <label for="m" style="font-size: 14px;">Mass <i> m </i> (kg)</label>
      <input type="number" id="m" value="1" step="0.1" min="0.1">
    </div>
  </div>

  <!-- Sliders: u0, uÌ‡0 -->
  <div id="controls">
    <div class="control" style="text-align:center; margin:auto;">
      <label for="u0" style="font-size: 14px;">
        Initial displacement<br>
        <i> uâ‚€ </i> (m) = <span id="u0_val">0.50</span>
      </label>
      <input type="range" id="u0" min="-1" max="1" step="0.01" value="0.5">
    </div>

    <div class="control" style="text-align:center; margin:auto;">
      <label for="ud0" style="font-size: 14px;">
        Initial velocity<br>
        <i> uÌ‡â‚€ </i> (m/s) = <span id="ud0_val">0.80</span>
      </label>
      <input type="range" id="ud0" min="-2" max="2" step="0.01" value="0.0">
    </div>
  </div>

  <canvas id="plot"></canvas>

  <script>
    // Sharper lines & larger fonts
    Chart.defaults.devicePixelRatio = 2;
    Chart.defaults.font.size = 14;

    const canvas = document.getElementById("plot");
    const ctx = canvas.getContext("2d");

    // Parameters
    let m = 1, k = 1;
    const T = 20, dt = 0.01;

    // Undamped free vibration response:
    // u(t) = u0 cos(wn t) + (ud0/wn) sin(wn t)
    function computeSeries(u0, ud0) {
      const wn = Math.sqrt(k / m);

      const pts = [];
      for (let i = 0; i <= T / dt; i++) {
        const t = i * dt;
        const u = u0 * Math.cos(wn * t) + (ud0 / wn) * Math.sin(wn * t);
        pts.push({ x: t, y: u });
      }
      return pts;
    }

    // Compute constant amplitude and the first (in-window) positive peak location
    function computeAmplitudeAndPeak(u0, ud0) {
      const wn = Math.sqrt(k / m);

      // u(t) = A cos(wn t) + B sin(wn t), with A=u0, B=ud0/wn
      const A = u0;
      const B = ud0 / wn;

      // Amplitude R = sqrt(A^2 + B^2)
      const R = Math.sqrt(A * A + B * B);

      // Phase phi such that u(t)=R cos(wn t - phi), with cos(phi)=A/R, sin(phi)=B/R
      // phi = atan2(B, A)
      let phi = Math.atan2(B, A);

      // Peak at wn t - phi = 0  => t_peak = phi/wn
      // Ensure t_peak is within [0, period)
      const period = (2 * Math.PI) / wn;
      let tPeak = phi / wn;

      while (tPeak < 0) tPeak += period;
      while (tPeak >= period) tPeak -= period;

      // If peak is outside current x-range, wrap it into [0, T]
      while (tPeak > T) tPeak -= period;
      if (tPeak < 0) tPeak = 0;

      return { R, tPeak };
    }

    // Custom plugin: draw black axes through (0,0)
    const axesLines = {
      id: 'axesLines',
      afterDraw(chart) {
        const { ctx, chartArea: { left, right, top, bottom }, scales: { x, y } } = chart;
        ctx.save();
        ctx.strokeStyle = 'black';
        ctx.lineWidth = 1.5;

        // x-axis (u = 0)
        const yZero = y.getPixelForValue(0);
        if (yZero >= top && yZero <= bottom) {
          ctx.beginPath();
          ctx.moveTo(left, yZero);
          ctx.lineTo(right, yZero);
          ctx.stroke();
        }

        // y-axis (t = 0)
        const xZero = x.getPixelForValue(0);
        if (xZero >= left && xZero <= right) {
          ctx.beginPath();
          ctx.moveTo(xZero, top);
          ctx.lineTo(xZero, bottom);
          ctx.stroke();
        }

        ctx.restore();
      }
    };

    // Custom plugin: draw amplitude pointer (arrow) and label
    const amplitudePointer = {
      id: 'amplitudePointer',
      afterDraw(chart) {
        const ampInfo = chart.$ampInfo;
        if (!ampInfo) return;

        const { R, tPeak } = ampInfo;
        const { ctx, chartArea: { left, right, top, bottom }, scales: { x, y } } = chart;

        // Only draw if the arrow will be visible in the plot area
        if (tPeak < x.min || tPeak > x.max) return;

        const xPix = x.getPixelForValue(tPeak);
        const yZeroPix = y.getPixelForValue(0);
        const yAmpPix = y.getPixelForValue(R);

        // Clip to chart area
        if (xPix < left || xPix > right) return;

        // Arrow style: black, solid
        ctx.save();
        ctx.strokeStyle = 'black';
        ctx.fillStyle = 'black';
        ctx.lineWidth = 1.5;

        // Draw vertical arrow line from 0 to +R
        const y1 = Math.min(Math.max(yZeroPix, top), bottom);
        const y2 = Math.min(Math.max(yAmpPix,  top), bottom);

        // If y2 is not in the visible area, do not draw
        if (y2 < top || y2 > bottom) {
          ctx.restore();
          return;
        }

        ctx.beginPath();
        ctx.moveTo(xPix, y1);
        ctx.lineTo(xPix, y2);
        ctx.stroke();

        // Arrow head
        const headLen = 10;
        const angleUp = -Math.PI / 2; // up
        ctx.beginPath();
        ctx.moveTo(xPix, y2);
        ctx.lineTo(xPix + headLen * Math.cos(angleUp + Math.PI / 6),
                   y2 + headLen * Math.sin(angleUp + Math.PI / 6));
        ctx.lineTo(xPix + headLen * Math.cos(angleUp - Math.PI / 6),
                   y2 + headLen * Math.sin(angleUp - Math.PI / 6));
        ctx.closePath();
        ctx.fill();

        // Mark the peak point
        ctx.beginPath();
        ctx.arc(xPix, y2, 3, 0, 2 * Math.PI);
        ctx.fill();

        // Label near the arrow head (keep inside plot area)
        const label = `u\u{2098}\u{2090}\u{2093} = ${R.toFixed(2)} m`;
        ctx.font = "14px Arial";
        ctx.textBaseline = "middle";

        let tx = xPix + 10;
        let ty = y2;

        // Prevent label from leaving the plot area
        const textWidth = ctx.measureText(label).width;
        if (tx + textWidth > right) tx = xPix - 10 - textWidth;
        if (ty < top + 10) ty = top + 10;
        if (ty > bottom - 10) ty = bottom - 10;

        ctx.fillText(label, tx, ty);

        ctx.restore();
      }
    };

    // Chart with one dataset: u(t)
    const chart = new Chart(ctx, {
      type: "line",
      data: {
        datasets: [
          {
            label: "ð‘¢(t)",
            data: [],
            borderColor: "red",
            borderWidth: 1.5,
            pointRadius: 0,
            fill: false,
            parsing: false
          }
        ]
      },
      options: {
        responsive: true,
        animation: false,
        scales: {
          x: {
            type: "linear",
            min: 0, max: 20,
            ticks: {
              color: "black",
              stepSize: 1,
              callback: v => Number.isInteger(v) ? v : ""
            },
            grid: { color: "#eee", drawBorder: false },
            title: { display: true, text: "Time ð‘¡ (s)", color: "black", font: { size: 16 } }
          },
          y: {
            min: -2, max: 2,
            ticks: { color: "black" },
            grid: { color: "#eee", drawBorder: false },
            title: { display: true, text: "Displacement ð‘¢(t) (m)", color: "black", font: { size: 16 } }
          }
        },
        plugins: {
          legend: {
            display: true,
            position: 'top',
            labels: {
              color: 'black',
              usePointStyle: false,
              boxWidth: 50,
              boxHeight: 0
            }
          }
        },
        layout: { padding: 10 }
      },
      plugins: [axesLines, amplitudePointer]
    });

    // Update on any input
    function updatePlot() {
      const u0  = parseFloat(document.getElementById("u0").value);
      const ud0 = parseFloat(document.getElementById("ud0").value);

      // Update labels
      document.getElementById("u0_val").textContent  = u0.toFixed(2);
      document.getElementById("ud0_val").textContent = ud0.toFixed(2);

      m = parseFloat(document.getElementById("m").value);
      k = parseFloat(document.getElementById("k").value);

      // Main response
      chart.data.datasets[0].data = computeSeries(u0, ud0);

      // Amplitude pointer info (stored on chart for plugin access)
      chart.$ampInfo = computeAmplitudeAndPeak(u0, ud0);

      chart.update();
    }

    // Attach listeners
    document.querySelectorAll("input").forEach(el =>
      el.addEventListener("input", updatePlot)
    );

    // Initial plot
    updatePlot();
  </script>
</body>
</html>
