<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>SDOF Free Vibration (Damped)</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      background: #fff;
      color: #000;
    }

    /* Keep constants and sliders in single rows */
    #constants, #controls {
      display: flex;
      justify-content: center;
      align-items: center;
      flex-wrap: nowrap;
      gap: 40px;
      margin: 10px 0;
    }

    .constant, .control {
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    input[type="number"], input[type="range"] {
      width: 160px;
    }

    input[type="number"] {
      text-align: center;
      border: 1px solid #ccc;
      border-radius: 4px;
      padding: 4px;
    }

    canvas {
      max-width: 800px;
      width: 100%;
      height: 400px;
      margin: 10px auto;
      display: block;
      background: #fff;
    }
  </style>
</head>
<body>
  <!-- Constants -->
  <div id="constants">
    <div class="constant">
      <label for="k" style="font-size: 14px;">Stiffness <i> k </i> (N/m)</label>
      <input type="number" id="k" value="1" step="0.1" min="0.5">
    </div>
    <div class="constant">
      <label for="m" style="font-size: 14px;">Mass <i> m </i> (kg)</label>
      <input type="number" id="m" value="1" step="0.1" min="0.1">
    </div>
  </div>

  <!-- Sliders: u0, uÌ‡0, Î¶ -->
  <div id="controls">
    <div class="control" style="text-align:center; margin:auto;">
      <label for="u0" style="font-size: 14px;">
        Initial displacement<br>
        <i> uâ‚€ </i> (m) = <span id="u0_val">0.50</span>
      </label>
      <!-- Non-zero default so graph is not empty -->
      <input type="range" id="u0" min="-1" max="1" step="0.01" value="0.5">
    </div>

    <div class="control" style="text-align:center; margin:auto;">
      <label for="ud0" style="font-size: 14px;">
        Initial velocity<br>
        <i> uÌ‡â‚€ </i> (m/s) = <span id="ud0_val">0.00</span>
      </label>
      <!-- Start at zero velocity, as you want -->
      <input type="range" id="ud0" min="-2" max="2" step="0.01" value="0.8">
    </div>

    <div class="control" style="text-align:center; margin:auto;">
      <label for="zeta" style="font-size:14px;">
        Damping ratio<br>
        <i> Î¶ </i> = <span id="zeta_val">0.050</span>
      </label>
      <!-- Small non-zero damping so decay is visible -->
      <input type="range" id="zeta" min="0" max="0.30" step="0.005" value="0.05">
    </div>
  </div>

  <canvas id="plot"></canvas>

  <script>
    // Sharper lines & larger fonts
    Chart.defaults.devicePixelRatio = 2;
    Chart.defaults.font.size = 14;

    const canvas = document.getElementById("plot");
    const ctx = canvas.getContext("2d");

    // Parameters
    let m = 1, k = 1, zeta = 0.05;
    const T = 20, dt = 0.01;

    // Free vibration response u(t) for 0 <= Î¶ < 1
    function computeSeries(u0, ud0) {
      const wn = Math.sqrt(k / m);
      const beta = Math.sqrt(Math.max(0, 1 - zeta * zeta));
      const wd = wn * beta;

      const pts = [];
      for (let i = 0; i <= T / dt; i++) {
        const t = i * dt;
        const expTerm = Math.exp(-zeta * wn * t);

        let u_free = 0;
        if (wd > 1e-8) {
          // u(t) = e^{-Î¶ Ï‰n t} [ u0 cos(Ï‰d t) + ((ud0 + Î¶ Ï‰n u0)/Ï‰d) sin(Ï‰d t) ]
          u_free = expTerm * (
            u0 * Math.cos(wd * t) +
            ((ud0 + zeta * wn * u0) / wd) * Math.sin(wd * t)
          );
        } else {
          // Near critical damping: approximate with non-oscillatory form
          u_free = expTerm * (u0 + (ud0 + zeta * wn * u0) * t);
        }

        pts.push({ x: t, y: u_free });
      }
      return pts;
    }

    // Exponential decay envelope that matches the peak amplitude
    function decayEnvelope(u0, ud0) {
      const wn = Math.sqrt(k / m);
      const beta = Math.sqrt(Math.max(0, 1 - zeta * zeta));
      const wd = wn * beta;

      const ptsPos = [];
      const ptsNeg = [];

      // If underdamped, compute amplitude R of oscillation
      let R = 0;
      if (wd > 1e-8) {
        const A = u0;
        const B = (ud0 + zeta * wn * u0) / wd;
        R = Math.sqrt(A * A + B * B);   // envelope amplitude
      }

      for (let i = 0; i <= T / dt; i++) {
        const t = i * dt;
        const env = R * Math.exp(-zeta * wn * t);
        ptsPos.push({ x: t, y:  env });
        ptsNeg.push({ x: t, y: -env });
      }

      return { pos: ptsPos, neg: ptsNeg };
    }

    // Custom plugin: draw black axes through (0,0)
    const axesLines = {
      id: 'axesLines',
      afterDraw(chart) {
        const { ctx, chartArea: { left, right, top, bottom }, scales: { x, y } } = chart;
        ctx.save();
        ctx.strokeStyle = 'black';
        ctx.lineWidth = 1.5;

        // x-axis (u = 0)
        const yZero = y.getPixelForValue(0);
        if (yZero >= top && yZero <= bottom) {
          ctx.beginPath();
          ctx.moveTo(left, yZero);
          ctx.lineTo(right, yZero);
          ctx.stroke();
        }

        // y-axis (t = 0)
        const xZero = x.getPixelForValue(0);
        if (xZero >= left && xZero <= right) {
          ctx.beginPath();
          ctx.moveTo(xZero, top);
          ctx.lineTo(xZero, bottom);
          ctx.stroke();
        }

        ctx.restore();
      }
    };

    // Chart with three datasets: u(t), +envelope, -envelope
    const chart = new Chart(ctx, {
      type: "line",
      data: {
        datasets: [
          {
            label: "ð‘¢(t)",
            data: [],              // will be set in updatePlot()
            borderColor: "red",
            borderWidth: 1.5,
            pointRadius: 0,
            fill: false,
            parsing: false
          },
          {
            label: "Decay envelope",
            data: [],
            borderColor: "black",
            borderWidth: 1,
            borderDash: [6, 6],
            pointRadius: 0,
            fill: false,
            parsing: false
          },
          {
            label: "Decay envelope âˆ’",
            data: [],
            borderColor: "black",
            borderWidth: 1,
            borderDash: [6, 6],
            pointRadius: 0,
            fill: false,
            parsing: false,
          }
        ]
      },
      options: {
        responsive: true,
        animation: false,
        scales: {
          x: {
            type: "linear",
            min: 0, max: 20,
            ticks: {
              color: "black",
              stepSize: 1,
              callback: v => Number.isInteger(v) ? v : ""
            },
            grid: { color: "#eee", drawBorder: false },
            title: { display: true, text: "Time ð‘¡ (s)", color: "black", font: { size: 16 } }
          },
          y: {
            min: -2, max: 2,
            ticks: { color: "black" },
            grid: { color: "#eee", drawBorder: false },
            title: { display: true, text: "Displacement ð‘¢(t) (m)", color: "black", font: { size: 16 } }
          }
        },
        plugins: {
          legend: {
            display: true,
            position: 'top',
            labels: {
              color: 'black',
              usePointStyle: false,
              boxWidth: 50,
              boxHeight: 0,
              // Hide decay lines from legend
              filter: function(item, chart) {
                // Hide ONLY the negative decay envelope
                return item.text !== "Decay envelope âˆ’";
              }
            }
          }
        },
        layout: { padding: 10 }
      },
      plugins: [axesLines]
    });

    // Update on any input
    function updatePlot() {
      const u0  = parseFloat(document.getElementById("u0").value);
      const ud0 = parseFloat(document.getElementById("ud0").value);
      zeta      = parseFloat(document.getElementById("zeta").value);

      // Update labels
      document.getElementById("u0_val").textContent   = u0.toFixed(2);
      document.getElementById("ud0_val").textContent  = ud0.toFixed(2);
      document.getElementById("zeta_val").textContent = zeta.toFixed(3);

      m  = parseFloat(document.getElementById("m").value);
      k  = parseFloat(document.getElementById("k").value);

      // Main response
      chart.data.datasets[0].data = computeSeries(u0, ud0);

      // Decay envelopes (matching the peak amplitude)
      const env = decayEnvelope(u0, ud0);
      chart.data.datasets[1].data = env.pos;
      chart.data.datasets[2].data = env.neg;

      chart.update();
    }

    // Attach listeners
    document.querySelectorAll("input").forEach(el =>
      el.addEventListener("input", updatePlot)
    );

    // Initial plot that matches default slider values
    updatePlot();
  </script>
</body>
</html>
